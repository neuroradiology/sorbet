digraph "t_enum_snapshot.rb" {
subgraph "cluster_::<Class:<root>>#<static-init>" {
    label = "::<Class:<root>>#<static-init>";
    color = blue;
    "bb::<Class:<root>>#<static-init>_0" [shape = invhouse];
    "bb::<Class:<root>>#<static-init>_1" [shape = parallelogram];

    "bb::<Class:<root>>#<static-init>_0" [
        label = "block[id=0, rubyBlockId=0]()\l<self>: T.class_of(<root>) = cast(<self>: NilClass, AppliedType {\l  klass = <S <C <U <root>>> $1>\l  targs = [\l    <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U <root>>> $1><C <U <AttachedClass>>>)\l  ]\l});\l<cfgAlias>$6: T.class_of(<Magic>) = alias <C <Magic>>\l<cfgAlias>$8: T.class_of(MyEnum) = alias <C MyEnum>\l<statTemp>$4: Sorbet::Private::Static::Void = <cfgAlias>$6: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$8: T.class_of(MyEnum))\l<cfgAlias>$11: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$13: T.class_of(MyEnum) = alias <C MyEnum>\l<statTemp>$9: Sorbet::Private::Static::Void = <cfgAlias>$11: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$13: T.class_of(MyEnum))\l<cfgAlias>$16: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$18: T.class_of(T::Enum) = alias <C Enum>\l<cfgAlias>$20: T.class_of(T) = alias <C T>\l<statTemp>$14: Sorbet::Private::Static::Void = <cfgAlias>$16: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$18: T.class_of(T::Enum))\l<cfgAlias>$24: T.class_of(<Magic>) = alias <C <Magic>>\l<cfgAlias>$26: T.class_of(NotAnEnum) = alias <C NotAnEnum>\l<statTemp>$22: Sorbet::Private::Static::Void = <cfgAlias>$24: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$26: T.class_of(NotAnEnum))\l<cfgAlias>$29: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$31: T.class_of(NotAnEnum) = alias <C NotAnEnum>\l<statTemp>$27: Sorbet::Private::Static::Void = <cfgAlias>$29: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$31: T.class_of(NotAnEnum))\l<cfgAlias>$35: T.class_of(<Magic>) = alias <C <Magic>>\l<cfgAlias>$37: T.class_of(EnumsDoEnum) = alias <C EnumsDoEnum>\l<statTemp>$33: Sorbet::Private::Static::Void = <cfgAlias>$35: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$37: T.class_of(EnumsDoEnum))\l<cfgAlias>$40: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$42: T.class_of(EnumsDoEnum) = alias <C EnumsDoEnum>\l<statTemp>$38: Sorbet::Private::Static::Void = <cfgAlias>$40: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$42: T.class_of(EnumsDoEnum))\l<cfgAlias>$45: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$47: T.class_of(T::Enum) = alias <C Enum>\l<cfgAlias>$49: T.class_of(T) = alias <C T>\l<statTemp>$43: Sorbet::Private::Static::Void = <cfgAlias>$45: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$47: T.class_of(T::Enum))\l<cfgAlias>$53: T.class_of(<Magic>) = alias <C <Magic>>\l<cfgAlias>$55: T.class_of(BadConsts) = alias <C BadConsts>\l<statTemp>$51: Sorbet::Private::Static::Void = <cfgAlias>$53: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$55: T.class_of(BadConsts))\l<cfgAlias>$58: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$60: T.class_of(BadConsts) = alias <C BadConsts>\l<statTemp>$56: Sorbet::Private::Static::Void = <cfgAlias>$58: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$60: T.class_of(BadConsts))\l<cfgAlias>$63: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$65: T.class_of(T::Enum) = alias <C Enum>\l<cfgAlias>$67: T.class_of(T) = alias <C T>\l<statTemp>$61: Sorbet::Private::Static::Void = <cfgAlias>$63: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$65: T.class_of(T::Enum))\l<finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass\l<unconditional>\l"
    ];

    "bb::<Class:<root>>#<static-init>_0" -> "bb::<Class:<root>>#<static-init>_1" [style="bold"];
    "bb::<Class:<root>>#<static-init>_1" [
        label = "block[id=1, rubyBlockId=0]()\l<unconditional>\l"
    ];

    "bb::<Class:<root>>#<static-init>_1" -> "bb::<Class:<root>>#<static-init>_1" [style="bold"];
}

subgraph "cluster_::<Class:MyEnum>#<static-init>" {
    label = "::<Class:MyEnum>#<static-init>";
    color = blue;
    "bb::<Class:MyEnum>#<static-init>_0" [shape = invhouse];
    "bb::<Class:MyEnum>#<static-init>_1" [shape = parallelogram];

    "bb::<Class:MyEnum>#<static-init>_0" [
        label = "block[id=0, rubyBlockId=0]()\l<C X>$35: MyEnum::X = alias <C X>\l<C Y>$61: MyEnum::Y = alias <C Y>\l<C Z>$88: MyEnum::Z = alias <C Z>\l<self>: T.class_of(MyEnum) = cast(<self>: NilClass, AppliedType {\l  klass = <S <C <U MyEnum>> $1>\l  targs = [\l    <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U MyEnum>> $1><C <U <AttachedClass>>>)\l  ]\l});\l<cfgAlias>$6: T.class_of(T::Helpers) = alias <C Helpers>\l<statTemp>$3: T.class_of(MyEnum) = <self>: T.class_of(MyEnum).extend(<cfgAlias>$6: T.class_of(T::Helpers))\l<statTemp>$7: Sorbet::Private::Static::Void = <self>: T.class_of(MyEnum).abstract!()\l<statTemp>$9: Sorbet::Private::Static::Void = <self>: T.class_of(MyEnum).sealed!()\l<block-pre-call-temp>$13: Sorbet::Private::Static::Void = <self>: T.class_of(MyEnum).enums()\l<selfRestore>$14: T.class_of(MyEnum) = <self>\l<unconditional>\l"
    ];

    "bb::<Class:MyEnum>#<static-init>_0" -> "bb::<Class:MyEnum>#<static-init>_2" [style="bold"];
    "bb::<Class:MyEnum>#<static-init>_1" [
        label = "block[id=1, rubyBlockId=0]()\l<unconditional>\l"
    ];

    "bb::<Class:MyEnum>#<static-init>_1" -> "bb::<Class:MyEnum>#<static-init>_1" [style="bold"];
    "bb::<Class:MyEnum>#<static-init>_2" [
        label = "block[id=2, rubyBlockId=1](<self>: T.class_of(MyEnum), <block-pre-call-temp>$13: Sorbet::Private::Static::Void, <selfRestore>$14: T.class_of(MyEnum), <C X>$35: MyEnum::X, <C Y>$61: MyEnum::Y, <C Z>$88: MyEnum::Z)\louterLoops: 1\l<block-call>: NilClass\l"
    ];

    "bb::<Class:MyEnum>#<static-init>_2" -> "bb::<Class:MyEnum>#<static-init>_5" [style="bold"];
    "bb::<Class:MyEnum>#<static-init>_2" -> "bb::<Class:MyEnum>#<static-init>_3" [style="tapered"];

    "bb::<Class:MyEnum>#<static-init>_3" [
        label = "block[id=3, rubyBlockId=0](<block-pre-call-temp>$13: Sorbet::Private::Static::Void, <selfRestore>$14: T.class_of(MyEnum))\l<statTemp>$11: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$13, enums>\l<finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass\l<unconditional>\l"
    ];

    "bb::<Class:MyEnum>#<static-init>_3" -> "bb::<Class:MyEnum>#<static-init>_1" [style="bold"];
    "bb::<Class:MyEnum>#<static-init>_5" [
        label = "block[id=5, rubyBlockId=1](<self>: T.class_of(MyEnum), <block-pre-call-temp>$13: Sorbet::Private::Static::Void, <selfRestore>$14: T.class_of(MyEnum), <C X>$35: MyEnum::X, <C Y>$61: MyEnum::Y, <C Z>$88: MyEnum::Z)\louterLoops: 1\l<self>: T.class_of(MyEnum) = loadSelf\l<cfgAlias>$21: T.class_of(<Magic>) = alias <C <Magic>>\l<cfgAlias>$23: T.class_of(MyEnum::X) = alias <C X$1>\l<statTemp>$19: Sorbet::Private::Static::Void = <cfgAlias>$21: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$23: T.class_of(MyEnum::X))\l<cfgAlias>$26: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$28: T.class_of(MyEnum::X) = alias <C X$1>\l<statTemp>$24: Sorbet::Private::Static::Void = <cfgAlias>$26: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$28: T.class_of(MyEnum::X))\l<cfgAlias>$31: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$33: T.class_of(MyEnum) = alias <C MyEnum>\l<statTemp>$29: Sorbet::Private::Static::Void = <cfgAlias>$31: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$33: T.class_of(MyEnum))\l<cfgAlias>$38: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$40: T.class_of(MyEnum::X) = alias <C X$1>\l<statTemp>$36: Sorbet::Private::Static::Void = <cfgAlias>$38: T.class_of(Sorbet::Private::Static).keep_for_typechecking(<cfgAlias>$40: T.class_of(MyEnum::X))\l<cfgAlias>$43: T.class_of(MyEnum::X) = alias <C X$1>\l<castTemp>$41: MyEnum::X = <cfgAlias>$43: T.class_of(MyEnum::X).new()\l<C X>$35: MyEnum::X = <castTemp>$41\l<cfgAlias>$47: T.class_of(<Magic>) = alias <C <Magic>>\l<cfgAlias>$49: T.class_of(MyEnum::Y) = alias <C Y$1>\l<statTemp>$45: Sorbet::Private::Static::Void = <cfgAlias>$47: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$49: T.class_of(MyEnum::Y))\l<cfgAlias>$52: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$54: T.class_of(MyEnum::Y) = alias <C Y$1>\l<statTemp>$50: Sorbet::Private::Static::Void = <cfgAlias>$52: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$54: T.class_of(MyEnum::Y))\l<cfgAlias>$57: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$59: T.class_of(MyEnum) = alias <C MyEnum>\l<statTemp>$55: Sorbet::Private::Static::Void = <cfgAlias>$57: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$59: T.class_of(MyEnum))\l<cfgAlias>$64: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$66: T.class_of(MyEnum::Y) = alias <C Y$1>\l<statTemp>$62: Sorbet::Private::Static::Void = <cfgAlias>$64: T.class_of(Sorbet::Private::Static).keep_for_typechecking(<cfgAlias>$66: T.class_of(MyEnum::Y))\l<cfgAlias>$69: T.class_of(MyEnum::Y) = alias <C Y$1>\l<statTemp>$70: String(\"y\") = \"y\"\l<castTemp>$67: MyEnum::Y = <cfgAlias>$69: T.class_of(MyEnum::Y).new(<statTemp>$70: String(\"y\"))\l<C Y>$61: MyEnum::Y = <castTemp>$67\l<cfgAlias>$74: T.class_of(<Magic>) = alias <C <Magic>>\l<cfgAlias>$76: T.class_of(MyEnum::Z) = alias <C Z$1>\l<statTemp>$72: Sorbet::Private::Static::Void = <cfgAlias>$74: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$76: T.class_of(MyEnum::Z))\l<cfgAlias>$79: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$81: T.class_of(MyEnum::Z) = alias <C Z$1>\l<statTemp>$77: Sorbet::Private::Static::Void = <cfgAlias>$79: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$81: T.class_of(MyEnum::Z))\l<cfgAlias>$84: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$86: T.class_of(MyEnum) = alias <C MyEnum>\l<statTemp>$82: Sorbet::Private::Static::Void = <cfgAlias>$84: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$86: T.class_of(MyEnum))\l<cfgAlias>$91: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$93: T.class_of(MyEnum::Z) = alias <C Z$1>\l<statTemp>$89: Sorbet::Private::Static::Void = <cfgAlias>$91: T.class_of(Sorbet::Private::Static).keep_for_typechecking(<cfgAlias>$93: T.class_of(MyEnum::Z))\l<cfgAlias>$96: T.class_of(MyEnum::Z) = alias <C Z$1>\l<castTemp>$94: MyEnum::Z = <cfgAlias>$96: T.class_of(MyEnum::Z).new(<self>: T.class_of(MyEnum))\l<C Z>$88: MyEnum::Z = <castTemp>$94\l<blockReturnTemp>$17: NilClass = nil\l<blockReturnTemp>$98: T.noreturn = blockreturn<enums> <blockReturnTemp>$17: NilClass\l<unconditional>\l"
    ];

    "bb::<Class:MyEnum>#<static-init>_5" -> "bb::<Class:MyEnum>#<static-init>_2" [style="bold"];
}

subgraph "cluster_::MyEnum::<Class:X>#<static-init>" {
    label = "::MyEnum::<Class:X>#<static-init>";
    color = blue;
    "bb::MyEnum::<Class:X>#<static-init>_0" [shape = invhouse];
    "bb::MyEnum::<Class:X>#<static-init>_1" [shape = parallelogram];

    "bb::MyEnum::<Class:X>#<static-init>_0" [
        label = "block[id=0, rubyBlockId=0]()\l<self>: T.class_of(MyEnum::X) = cast(<self>: NilClass, AppliedType {\l  klass = <C <U MyEnum>><S <C <E <C <U X>> $1>> $1>\l  targs = [\l    <C <U <AttachedClass>>> = SelfTypeParam(<C <U MyEnum>><S <C <E <C <U X>> $1>> $1><C <U <AttachedClass>>>)\l  ]\l});\l<finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass\l<unconditional>\l"
    ];

    "bb::MyEnum::<Class:X>#<static-init>_0" -> "bb::MyEnum::<Class:X>#<static-init>_1" [style="bold"];
    "bb::MyEnum::<Class:X>#<static-init>_1" [
        label = "block[id=1, rubyBlockId=0]()\l<unconditional>\l"
    ];

    "bb::MyEnum::<Class:X>#<static-init>_1" -> "bb::MyEnum::<Class:X>#<static-init>_1" [style="bold"];
}

subgraph "cluster_::MyEnum::<Class:Y>#<static-init>" {
    label = "::MyEnum::<Class:Y>#<static-init>";
    color = blue;
    "bb::MyEnum::<Class:Y>#<static-init>_0" [shape = invhouse];
    "bb::MyEnum::<Class:Y>#<static-init>_1" [shape = parallelogram];

    "bb::MyEnum::<Class:Y>#<static-init>_0" [
        label = "block[id=0, rubyBlockId=0]()\l<self>: T.class_of(MyEnum::Y) = cast(<self>: NilClass, AppliedType {\l  klass = <C <U MyEnum>><S <C <E <C <U Y>> $1>> $1>\l  targs = [\l    <C <U <AttachedClass>>> = SelfTypeParam(<C <U MyEnum>><S <C <E <C <U Y>> $1>> $1><C <U <AttachedClass>>>)\l  ]\l});\l<finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass\l<unconditional>\l"
    ];

    "bb::MyEnum::<Class:Y>#<static-init>_0" -> "bb::MyEnum::<Class:Y>#<static-init>_1" [style="bold"];
    "bb::MyEnum::<Class:Y>#<static-init>_1" [
        label = "block[id=1, rubyBlockId=0]()\l<unconditional>\l"
    ];

    "bb::MyEnum::<Class:Y>#<static-init>_1" -> "bb::MyEnum::<Class:Y>#<static-init>_1" [style="bold"];
}

subgraph "cluster_::MyEnum::<Class:Z>#<static-init>" {
    label = "::MyEnum::<Class:Z>#<static-init>";
    color = blue;
    "bb::MyEnum::<Class:Z>#<static-init>_0" [shape = invhouse];
    "bb::MyEnum::<Class:Z>#<static-init>_1" [shape = parallelogram];

    "bb::MyEnum::<Class:Z>#<static-init>_0" [
        label = "block[id=0, rubyBlockId=0]()\l<self>: T.class_of(MyEnum::Z) = cast(<self>: NilClass, AppliedType {\l  klass = <C <U MyEnum>><S <C <E <C <U Z>> $1>> $1>\l  targs = [\l    <C <U <AttachedClass>>> = SelfTypeParam(<C <U MyEnum>><S <C <E <C <U Z>> $1>> $1><C <U <AttachedClass>>>)\l  ]\l});\l<finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass\l<unconditional>\l"
    ];

    "bb::MyEnum::<Class:Z>#<static-init>_0" -> "bb::MyEnum::<Class:Z>#<static-init>_1" [style="bold"];
    "bb::MyEnum::<Class:Z>#<static-init>_1" [
        label = "block[id=1, rubyBlockId=0]()\l<unconditional>\l"
    ];

    "bb::MyEnum::<Class:Z>#<static-init>_1" -> "bb::MyEnum::<Class:Z>#<static-init>_1" [style="bold"];
}

subgraph "cluster_::<Class:NotAnEnum>#<static-init>" {
    label = "::<Class:NotAnEnum>#<static-init>";
    color = blue;
    "bb::<Class:NotAnEnum>#<static-init>_0" [shape = invhouse];
    "bb::<Class:NotAnEnum>#<static-init>_1" [shape = parallelogram];

    "bb::<Class:NotAnEnum>#<static-init>_0" [
        label = "block[id=0, rubyBlockId=0]()\l<C X>$10: T.untyped = alias <C X>\l<C Y>$17: NotAnEnum = alias <C Y>\l<self>: T.class_of(NotAnEnum) = cast(<self>: NilClass, AppliedType {\l  klass = <S <C <U NotAnEnum>> $1>\l  targs = [\l    <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U NotAnEnum>> $1><C <U <AttachedClass>>>)\l  ]\l});\l<block-pre-call-temp>$4: Sorbet::Private::Static::Void = <self>: T.class_of(NotAnEnum).enums()\l<selfRestore>$5: T.class_of(NotAnEnum) = <self>\l<unconditional>\l"
    ];

    "bb::<Class:NotAnEnum>#<static-init>_0" -> "bb::<Class:NotAnEnum>#<static-init>_2" [style="bold"];
    "bb::<Class:NotAnEnum>#<static-init>_1" [
        label = "block[id=1, rubyBlockId=0]()\l<unconditional>\l"
    ];

    "bb::<Class:NotAnEnum>#<static-init>_1" -> "bb::<Class:NotAnEnum>#<static-init>_1" [style="bold"];
    "bb::<Class:NotAnEnum>#<static-init>_2" [
        label = "block[id=2, rubyBlockId=1](<self>: T.class_of(NotAnEnum), <block-pre-call-temp>$4: Sorbet::Private::Static::Void, <selfRestore>$5: T.class_of(NotAnEnum), <C X>$10: T.untyped, <C Y>$17: NotAnEnum)\louterLoops: 1\l<block-call>: NilClass\l"
    ];

    "bb::<Class:NotAnEnum>#<static-init>_2" -> "bb::<Class:NotAnEnum>#<static-init>_5" [style="bold"];
    "bb::<Class:NotAnEnum>#<static-init>_2" -> "bb::<Class:NotAnEnum>#<static-init>_3" [style="tapered"];

    "bb::<Class:NotAnEnum>#<static-init>_3" [
        label = "block[id=3, rubyBlockId=0](<block-pre-call-temp>$4: Sorbet::Private::Static::Void, <selfRestore>$5: T.class_of(NotAnEnum))\l<returnMethodTemp>$2: T.untyped = Solve<<block-pre-call-temp>$4, enums>\l<finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.untyped\l<unconditional>\l"
    ];

    "bb::<Class:NotAnEnum>#<static-init>_3" -> "bb::<Class:NotAnEnum>#<static-init>_1" [style="bold"];
    "bb::<Class:NotAnEnum>#<static-init>_5" [
        label = "block[id=5, rubyBlockId=1](<self>: T.class_of(NotAnEnum), <block-pre-call-temp>$4: Sorbet::Private::Static::Void, <selfRestore>$5: T.class_of(NotAnEnum), <C X>$10: T.untyped, <C Y>$17: NotAnEnum)\louterLoops: 1\l<self>: T.class_of(NotAnEnum) = loadSelf\l<cfgAlias>$12: T.class_of(<Magic>) = alias <C <Magic>>\l<cfgAlias>$15: T.class_of(<Magic>) = alias <C <Magic>>\l<statTemp>$13: T.attached_class (of NotAnEnum) = <cfgAlias>$15: T.class_of(<Magic>).<self-new>(<self>: T.class_of(NotAnEnum))\l<C X>$10: T.attached_class (of NotAnEnum) = <cfgAlias>$12: T.class_of(<Magic>).<suggest-type>(<statTemp>$13: T.attached_class (of NotAnEnum))\l<cfgAlias>$20: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<statTemp>$18: Sorbet::Private::Static::Void = <cfgAlias>$20: T.class_of(Sorbet::Private::Static).keep_for_typechecking(<self>: T.class_of(NotAnEnum))\l<cfgAlias>$24: T.class_of(<Magic>) = alias <C <Magic>>\l<castTemp>$22: T.attached_class (of NotAnEnum) = <cfgAlias>$24: T.class_of(<Magic>).<self-new>(<self>: T.class_of(NotAnEnum))\l<C Y>$17: NotAnEnum = cast(<castTemp>$22: T.attached_class (of NotAnEnum), NotAnEnum);\l<blockReturnTemp>$8: NotAnEnum = <C Y>$17\l<blockReturnTemp>$26: T.noreturn = blockreturn<enums> <blockReturnTemp>$8: NotAnEnum\l<unconditional>\l"
    ];

    "bb::<Class:NotAnEnum>#<static-init>_5" -> "bb::<Class:NotAnEnum>#<static-init>_2" [style="bold"];
}

subgraph "cluster_::EnumsDoEnum#something_outside" {
    label = "::EnumsDoEnum#something_outside";
    color = blue;
    "bb::EnumsDoEnum#something_outside_0" [shape = invhouse];
    "bb::EnumsDoEnum#something_outside_1" [shape = parallelogram];

    "bb::EnumsDoEnum#something_outside_0" [
        label = "block[id=0, rubyBlockId=0]()\l<self>: EnumsDoEnum = cast(<self>: NilClass, EnumsDoEnum);\l<finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass\l<unconditional>\l"
    ];

    "bb::EnumsDoEnum#something_outside_0" -> "bb::EnumsDoEnum#something_outside_1" [style="bold"];
    "bb::EnumsDoEnum#something_outside_1" [
        label = "block[id=1, rubyBlockId=0]()\l<unconditional>\l"
    ];

    "bb::EnumsDoEnum#something_outside_1" -> "bb::EnumsDoEnum#something_outside_1" [style="bold"];
}

subgraph "cluster_::<Class:EnumsDoEnum>#<static-init>" {
    label = "::<Class:EnumsDoEnum>#<static-init>";
    color = blue;
    "bb::<Class:EnumsDoEnum>#<static-init>_0" [shape = invhouse];
    "bb::<Class:EnumsDoEnum>#<static-init>_1" [shape = parallelogram];

    "bb::<Class:EnumsDoEnum>#<static-init>_0" [
        label = "block[id=0, rubyBlockId=0]()\l<C X>$35: EnumsDoEnum::X = alias <C X>\l<C Y>$61: EnumsDoEnum::Y = alias <C Y>\l<C Z>$88: EnumsDoEnum::Z = alias <C Z>\l<self>: T.class_of(EnumsDoEnum) = cast(<self>: NilClass, AppliedType {\l  klass = <S <C <U EnumsDoEnum>> $1>\l  targs = [\l    <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U EnumsDoEnum>> $1><C <U <AttachedClass>>>)\l  ]\l});\l<cfgAlias>$6: T.class_of(T::Helpers) = alias <C Helpers>\l<statTemp>$3: T.class_of(EnumsDoEnum) = <self>: T.class_of(EnumsDoEnum).extend(<cfgAlias>$6: T.class_of(T::Helpers))\l<statTemp>$7: Sorbet::Private::Static::Void = <self>: T.class_of(EnumsDoEnum).abstract!()\l<statTemp>$9: Sorbet::Private::Static::Void = <self>: T.class_of(EnumsDoEnum).sealed!()\l<block-pre-call-temp>$13: Sorbet::Private::Static::Void = <self>: T.class_of(EnumsDoEnum).enums()\l<selfRestore>$14: T.class_of(EnumsDoEnum) = <self>\l<unconditional>\l"
    ];

    "bb::<Class:EnumsDoEnum>#<static-init>_0" -> "bb::<Class:EnumsDoEnum>#<static-init>_2" [style="bold"];
    "bb::<Class:EnumsDoEnum>#<static-init>_1" [
        label = "block[id=1, rubyBlockId=0]()\l<unconditional>\l"
    ];

    "bb::<Class:EnumsDoEnum>#<static-init>_1" -> "bb::<Class:EnumsDoEnum>#<static-init>_1" [style="bold"];
    "bb::<Class:EnumsDoEnum>#<static-init>_2" [
        label = "block[id=2, rubyBlockId=1](<self>: T.class_of(EnumsDoEnum), <block-pre-call-temp>$13: Sorbet::Private::Static::Void, <selfRestore>$14: T.class_of(EnumsDoEnum), <C X>$35: EnumsDoEnum::X, <C Y>$61: EnumsDoEnum::Y, <C Z>$88: EnumsDoEnum::Z)\louterLoops: 1\l<block-call>: NilClass\l"
    ];

    "bb::<Class:EnumsDoEnum>#<static-init>_2" -> "bb::<Class:EnumsDoEnum>#<static-init>_5" [style="bold"];
    "bb::<Class:EnumsDoEnum>#<static-init>_2" -> "bb::<Class:EnumsDoEnum>#<static-init>_3" [style="tapered"];

    "bb::<Class:EnumsDoEnum>#<static-init>_3" [
        label = "block[id=3, rubyBlockId=0](<block-pre-call-temp>$13: Sorbet::Private::Static::Void, <selfRestore>$14: T.class_of(EnumsDoEnum))\l<statTemp>$11: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$13, enums>\l<self>: T.class_of(EnumsDoEnum) = <selfRestore>$14\l<cfgAlias>$101: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<statTemp>$103: Symbol(:something_outside) = :something_outside\l<statTemp>$99: Symbol(:something_outside) = <cfgAlias>$101: T.class_of(Sorbet::Private::Static).keep_def(<self>: T.class_of(EnumsDoEnum), <statTemp>$103: Symbol(:something_outside))\l<finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass\l<unconditional>\l"
    ];

    "bb::<Class:EnumsDoEnum>#<static-init>_3" -> "bb::<Class:EnumsDoEnum>#<static-init>_1" [style="bold"];
    "bb::<Class:EnumsDoEnum>#<static-init>_5" [
        label = "block[id=5, rubyBlockId=1](<self>: T.class_of(EnumsDoEnum), <block-pre-call-temp>$13: Sorbet::Private::Static::Void, <selfRestore>$14: T.class_of(EnumsDoEnum), <C X>$35: EnumsDoEnum::X, <C Y>$61: EnumsDoEnum::Y, <C Z>$88: EnumsDoEnum::Z)\louterLoops: 1\l<self>: T.class_of(EnumsDoEnum) = loadSelf\l<cfgAlias>$21: T.class_of(<Magic>) = alias <C <Magic>>\l<cfgAlias>$23: T.class_of(EnumsDoEnum::X) = alias <C X$1>\l<statTemp>$19: Sorbet::Private::Static::Void = <cfgAlias>$21: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$23: T.class_of(EnumsDoEnum::X))\l<cfgAlias>$26: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$28: T.class_of(EnumsDoEnum::X) = alias <C X$1>\l<statTemp>$24: Sorbet::Private::Static::Void = <cfgAlias>$26: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$28: T.class_of(EnumsDoEnum::X))\l<cfgAlias>$31: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$33: T.class_of(EnumsDoEnum) = alias <C EnumsDoEnum>\l<statTemp>$29: Sorbet::Private::Static::Void = <cfgAlias>$31: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$33: T.class_of(EnumsDoEnum))\l<cfgAlias>$38: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$40: T.class_of(EnumsDoEnum::X) = alias <C X$1>\l<statTemp>$36: Sorbet::Private::Static::Void = <cfgAlias>$38: T.class_of(Sorbet::Private::Static).keep_for_typechecking(<cfgAlias>$40: T.class_of(EnumsDoEnum::X))\l<cfgAlias>$43: T.class_of(EnumsDoEnum::X) = alias <C X$1>\l<castTemp>$41: EnumsDoEnum::X = <cfgAlias>$43: T.class_of(EnumsDoEnum::X).new()\l<C X>$35: EnumsDoEnum::X = <castTemp>$41\l<cfgAlias>$47: T.class_of(<Magic>) = alias <C <Magic>>\l<cfgAlias>$49: T.class_of(EnumsDoEnum::Y) = alias <C Y$1>\l<statTemp>$45: Sorbet::Private::Static::Void = <cfgAlias>$47: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$49: T.class_of(EnumsDoEnum::Y))\l<cfgAlias>$52: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$54: T.class_of(EnumsDoEnum::Y) = alias <C Y$1>\l<statTemp>$50: Sorbet::Private::Static::Void = <cfgAlias>$52: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$54: T.class_of(EnumsDoEnum::Y))\l<cfgAlias>$57: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$59: T.class_of(EnumsDoEnum) = alias <C EnumsDoEnum>\l<statTemp>$55: Sorbet::Private::Static::Void = <cfgAlias>$57: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$59: T.class_of(EnumsDoEnum))\l<cfgAlias>$64: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$66: T.class_of(EnumsDoEnum::Y) = alias <C Y$1>\l<statTemp>$62: Sorbet::Private::Static::Void = <cfgAlias>$64: T.class_of(Sorbet::Private::Static).keep_for_typechecking(<cfgAlias>$66: T.class_of(EnumsDoEnum::Y))\l<cfgAlias>$69: T.class_of(EnumsDoEnum::Y) = alias <C Y$1>\l<statTemp>$70: String(\"y\") = \"y\"\l<castTemp>$67: EnumsDoEnum::Y = <cfgAlias>$69: T.class_of(EnumsDoEnum::Y).new(<statTemp>$70: String(\"y\"))\l<C Y>$61: EnumsDoEnum::Y = <castTemp>$67\l<cfgAlias>$74: T.class_of(<Magic>) = alias <C <Magic>>\l<cfgAlias>$76: T.class_of(EnumsDoEnum::Z) = alias <C Z$1>\l<statTemp>$72: Sorbet::Private::Static::Void = <cfgAlias>$74: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$76: T.class_of(EnumsDoEnum::Z))\l<cfgAlias>$79: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$81: T.class_of(EnumsDoEnum::Z) = alias <C Z$1>\l<statTemp>$77: Sorbet::Private::Static::Void = <cfgAlias>$79: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$81: T.class_of(EnumsDoEnum::Z))\l<cfgAlias>$84: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$86: T.class_of(EnumsDoEnum) = alias <C EnumsDoEnum>\l<statTemp>$82: Sorbet::Private::Static::Void = <cfgAlias>$84: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$86: T.class_of(EnumsDoEnum))\l<cfgAlias>$91: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$93: T.class_of(EnumsDoEnum::Z) = alias <C Z$1>\l<statTemp>$89: Sorbet::Private::Static::Void = <cfgAlias>$91: T.class_of(Sorbet::Private::Static).keep_for_typechecking(<cfgAlias>$93: T.class_of(EnumsDoEnum::Z))\l<cfgAlias>$96: T.class_of(EnumsDoEnum::Z) = alias <C Z$1>\l<castTemp>$94: EnumsDoEnum::Z = <cfgAlias>$96: T.class_of(EnumsDoEnum::Z).new(<self>: T.class_of(EnumsDoEnum))\l<C Z>$88: EnumsDoEnum::Z = <castTemp>$94\l<blockReturnTemp>$17: NilClass = nil\l<blockReturnTemp>$98: T.noreturn = blockreturn<enums> <blockReturnTemp>$17: NilClass\l<unconditional>\l"
    ];

    "bb::<Class:EnumsDoEnum>#<static-init>_5" -> "bb::<Class:EnumsDoEnum>#<static-init>_2" [style="bold"];
}

subgraph "cluster_::EnumsDoEnum::<Class:X>#<static-init>" {
    label = "::EnumsDoEnum::<Class:X>#<static-init>";
    color = blue;
    "bb::EnumsDoEnum::<Class:X>#<static-init>_0" [shape = invhouse];
    "bb::EnumsDoEnum::<Class:X>#<static-init>_1" [shape = parallelogram];

    "bb::EnumsDoEnum::<Class:X>#<static-init>_0" [
        label = "block[id=0, rubyBlockId=0]()\l<self>: T.class_of(EnumsDoEnum::X) = cast(<self>: NilClass, AppliedType {\l  klass = <C <U EnumsDoEnum>><S <C <E <C <U X>> $1>> $1>\l  targs = [\l    <C <U <AttachedClass>>> = SelfTypeParam(<C <U EnumsDoEnum>><S <C <E <C <U X>> $1>> $1><C <U <AttachedClass>>>)\l  ]\l});\l<finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass\l<unconditional>\l"
    ];

    "bb::EnumsDoEnum::<Class:X>#<static-init>_0" -> "bb::EnumsDoEnum::<Class:X>#<static-init>_1" [style="bold"];
    "bb::EnumsDoEnum::<Class:X>#<static-init>_1" [
        label = "block[id=1, rubyBlockId=0]()\l<unconditional>\l"
    ];

    "bb::EnumsDoEnum::<Class:X>#<static-init>_1" -> "bb::EnumsDoEnum::<Class:X>#<static-init>_1" [style="bold"];
}

subgraph "cluster_::EnumsDoEnum::<Class:Y>#<static-init>" {
    label = "::EnumsDoEnum::<Class:Y>#<static-init>";
    color = blue;
    "bb::EnumsDoEnum::<Class:Y>#<static-init>_0" [shape = invhouse];
    "bb::EnumsDoEnum::<Class:Y>#<static-init>_1" [shape = parallelogram];

    "bb::EnumsDoEnum::<Class:Y>#<static-init>_0" [
        label = "block[id=0, rubyBlockId=0]()\l<self>: T.class_of(EnumsDoEnum::Y) = cast(<self>: NilClass, AppliedType {\l  klass = <C <U EnumsDoEnum>><S <C <E <C <U Y>> $1>> $1>\l  targs = [\l    <C <U <AttachedClass>>> = SelfTypeParam(<C <U EnumsDoEnum>><S <C <E <C <U Y>> $1>> $1><C <U <AttachedClass>>>)\l  ]\l});\l<finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass\l<unconditional>\l"
    ];

    "bb::EnumsDoEnum::<Class:Y>#<static-init>_0" -> "bb::EnumsDoEnum::<Class:Y>#<static-init>_1" [style="bold"];
    "bb::EnumsDoEnum::<Class:Y>#<static-init>_1" [
        label = "block[id=1, rubyBlockId=0]()\l<unconditional>\l"
    ];

    "bb::EnumsDoEnum::<Class:Y>#<static-init>_1" -> "bb::EnumsDoEnum::<Class:Y>#<static-init>_1" [style="bold"];
}

subgraph "cluster_::EnumsDoEnum::<Class:Z>#<static-init>" {
    label = "::EnumsDoEnum::<Class:Z>#<static-init>";
    color = blue;
    "bb::EnumsDoEnum::<Class:Z>#<static-init>_0" [shape = invhouse];
    "bb::EnumsDoEnum::<Class:Z>#<static-init>_1" [shape = parallelogram];

    "bb::EnumsDoEnum::<Class:Z>#<static-init>_0" [
        label = "block[id=0, rubyBlockId=0]()\l<self>: T.class_of(EnumsDoEnum::Z) = cast(<self>: NilClass, AppliedType {\l  klass = <C <U EnumsDoEnum>><S <C <E <C <U Z>> $1>> $1>\l  targs = [\l    <C <U <AttachedClass>>> = SelfTypeParam(<C <U EnumsDoEnum>><S <C <E <C <U Z>> $1>> $1><C <U <AttachedClass>>>)\l  ]\l});\l<finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass\l<unconditional>\l"
    ];

    "bb::EnumsDoEnum::<Class:Z>#<static-init>_0" -> "bb::EnumsDoEnum::<Class:Z>#<static-init>_1" [style="bold"];
    "bb::EnumsDoEnum::<Class:Z>#<static-init>_1" [
        label = "block[id=1, rubyBlockId=0]()\l<unconditional>\l"
    ];

    "bb::EnumsDoEnum::<Class:Z>#<static-init>_1" -> "bb::EnumsDoEnum::<Class:Z>#<static-init>_1" [style="bold"];
}

subgraph "cluster_::<Class:BadConsts>#<static-init>" {
    label = "::<Class:BadConsts>#<static-init>";
    color = blue;
    "bb::<Class:BadConsts>#<static-init>_0" [shape = invhouse];
    "bb::<Class:BadConsts>#<static-init>_1" [shape = parallelogram];

    "bb::<Class:BadConsts>#<static-init>_0" [
        label = "block[id=0, rubyBlockId=0]()\l<C Before>$28: BadConsts::Before = alias <C Before>\l<C StaticField1>$38: Integer(1) = alias <C StaticField1>\l<C Inside>$63: BadConsts::Inside = alias <C Inside>\l<C StaticField2>$73: Integer(2) = alias <C StaticField2>\l<C After>$92: BadConsts::After = alias <C After>\l<C StaticField3>$102: Integer(3) = alias <C StaticField3>\l<C StaticField4>$104: Integer = alias <C StaticField4>\l<self>: T.class_of(BadConsts) = cast(<self>: NilClass, AppliedType {\l  klass = <S <C <U BadConsts>> $1>\l  targs = [\l    <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U BadConsts>> $1><C <U <AttachedClass>>>)\l  ]\l});\l<cfgAlias>$6: T.class_of(T::Helpers) = alias <C Helpers>\l<statTemp>$3: T.class_of(BadConsts) = <self>: T.class_of(BadConsts).extend(<cfgAlias>$6: T.class_of(T::Helpers))\l<statTemp>$7: Sorbet::Private::Static::Void = <self>: T.class_of(BadConsts).abstract!()\l<statTemp>$9: Sorbet::Private::Static::Void = <self>: T.class_of(BadConsts).sealed!()\l<cfgAlias>$14: T.class_of(<Magic>) = alias <C <Magic>>\l<cfgAlias>$16: T.class_of(BadConsts::Before) = alias <C Before$1>\l<statTemp>$12: Sorbet::Private::Static::Void = <cfgAlias>$14: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$16: T.class_of(BadConsts::Before))\l<cfgAlias>$19: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$21: T.class_of(BadConsts::Before) = alias <C Before$1>\l<statTemp>$17: Sorbet::Private::Static::Void = <cfgAlias>$19: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$21: T.class_of(BadConsts::Before))\l<cfgAlias>$24: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$26: T.class_of(BadConsts) = alias <C BadConsts>\l<statTemp>$22: Sorbet::Private::Static::Void = <cfgAlias>$24: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$26: T.class_of(BadConsts))\l<cfgAlias>$31: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$33: T.class_of(BadConsts::Before) = alias <C Before$1>\l<statTemp>$29: Sorbet::Private::Static::Void = <cfgAlias>$31: T.class_of(Sorbet::Private::Static).keep_for_typechecking(<cfgAlias>$33: T.class_of(BadConsts::Before))\l<cfgAlias>$36: T.class_of(BadConsts::Before) = alias <C Before$1>\l<castTemp>$34: BadConsts::Before = <cfgAlias>$36: T.class_of(BadConsts::Before).new()\l<C Before>$28: BadConsts::Before = <castTemp>$34\l<C StaticField1>$38: Integer(1) = 1\l<block-pre-call-temp>$41: Sorbet::Private::Static::Void = <self>: T.class_of(BadConsts).enums()\l<selfRestore>$42: T.class_of(BadConsts) = <self>\l<unconditional>\l"
    ];

    "bb::<Class:BadConsts>#<static-init>_0" -> "bb::<Class:BadConsts>#<static-init>_2" [style="bold"];
    "bb::<Class:BadConsts>#<static-init>_1" [
        label = "block[id=1, rubyBlockId=0]()\l<unconditional>\l"
    ];

    "bb::<Class:BadConsts>#<static-init>_1" -> "bb::<Class:BadConsts>#<static-init>_1" [style="bold"];
    "bb::<Class:BadConsts>#<static-init>_2" [
        label = "block[id=2, rubyBlockId=1](<self>: T.class_of(BadConsts), <block-pre-call-temp>$41: Sorbet::Private::Static::Void, <selfRestore>$42: T.class_of(BadConsts), <C Inside>$63: BadConsts::Inside, <C StaticField2>$73: Integer(2), <C After>$92: BadConsts::After, <C StaticField3>$102: Integer(3), <C StaticField4>$104: Integer)\louterLoops: 1\l<block-call>: NilClass\l"
    ];

    "bb::<Class:BadConsts>#<static-init>_2" -> "bb::<Class:BadConsts>#<static-init>_5" [style="bold"];
    "bb::<Class:BadConsts>#<static-init>_2" -> "bb::<Class:BadConsts>#<static-init>_3" [style="tapered"];

    "bb::<Class:BadConsts>#<static-init>_3" [
        label = "block[id=3, rubyBlockId=0](<block-pre-call-temp>$41: Sorbet::Private::Static::Void, <selfRestore>$42: T.class_of(BadConsts), <C After>$92: BadConsts::After, <C StaticField3>$102: Integer(3), <C StaticField4>$104: Integer)\l<statTemp>$39: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$41, enums>\l<cfgAlias>$78: T.class_of(<Magic>) = alias <C <Magic>>\l<cfgAlias>$80: T.class_of(BadConsts::After) = alias <C After$1>\l<statTemp>$76: Sorbet::Private::Static::Void = <cfgAlias>$78: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$80: T.class_of(BadConsts::After))\l<cfgAlias>$83: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$85: T.class_of(BadConsts::After) = alias <C After$1>\l<statTemp>$81: Sorbet::Private::Static::Void = <cfgAlias>$83: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$85: T.class_of(BadConsts::After))\l<cfgAlias>$88: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$90: T.class_of(BadConsts) = alias <C BadConsts>\l<statTemp>$86: Sorbet::Private::Static::Void = <cfgAlias>$88: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$90: T.class_of(BadConsts))\l<cfgAlias>$95: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$97: T.class_of(BadConsts::After) = alias <C After$1>\l<statTemp>$93: Sorbet::Private::Static::Void = <cfgAlias>$95: T.class_of(Sorbet::Private::Static).keep_for_typechecking(<cfgAlias>$97: T.class_of(BadConsts::After))\l<cfgAlias>$100: T.class_of(BadConsts::After) = alias <C After$1>\l<castTemp>$98: BadConsts::After = <cfgAlias>$100: T.class_of(BadConsts::After).new()\l<C After>$92: BadConsts::After = <castTemp>$98\l<C StaticField3>$102: Integer(3) = 3\l<cfgAlias>$107: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$109: T.class_of(Integer) = alias <C Integer>\l<statTemp>$105: Sorbet::Private::Static::Void = <cfgAlias>$107: T.class_of(Sorbet::Private::Static).keep_for_typechecking(<cfgAlias>$109: T.class_of(Integer))\l<castTemp>$110: Integer(1) = 1\l<C StaticField4>$104: Integer = cast(<castTemp>$110: Integer(1), Integer);\l<finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass\l<unconditional>\l"
    ];

    "bb::<Class:BadConsts>#<static-init>_3" -> "bb::<Class:BadConsts>#<static-init>_1" [style="bold"];
    "bb::<Class:BadConsts>#<static-init>_5" [
        label = "block[id=5, rubyBlockId=1](<self>: T.class_of(BadConsts), <block-pre-call-temp>$41: Sorbet::Private::Static::Void, <selfRestore>$42: T.class_of(BadConsts), <C Inside>$63: BadConsts::Inside, <C StaticField2>$73: Integer(2), <C After>$92: BadConsts::After, <C StaticField3>$102: Integer(3), <C StaticField4>$104: Integer)\louterLoops: 1\l<self>: T.class_of(BadConsts) = loadSelf\l<cfgAlias>$49: T.class_of(<Magic>) = alias <C <Magic>>\l<cfgAlias>$51: T.class_of(BadConsts::Inside) = alias <C Inside$1>\l<statTemp>$47: Sorbet::Private::Static::Void = <cfgAlias>$49: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$51: T.class_of(BadConsts::Inside))\l<cfgAlias>$54: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$56: T.class_of(BadConsts::Inside) = alias <C Inside$1>\l<statTemp>$52: Sorbet::Private::Static::Void = <cfgAlias>$54: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$56: T.class_of(BadConsts::Inside))\l<cfgAlias>$59: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$61: T.class_of(BadConsts) = alias <C BadConsts>\l<statTemp>$57: Sorbet::Private::Static::Void = <cfgAlias>$59: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$61: T.class_of(BadConsts))\l<cfgAlias>$66: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$68: T.class_of(BadConsts::Inside) = alias <C Inside$1>\l<statTemp>$64: Sorbet::Private::Static::Void = <cfgAlias>$66: T.class_of(Sorbet::Private::Static).keep_for_typechecking(<cfgAlias>$68: T.class_of(BadConsts::Inside))\l<cfgAlias>$71: T.class_of(BadConsts::Inside) = alias <C Inside$1>\l<castTemp>$69: BadConsts::Inside = <cfgAlias>$71: T.class_of(BadConsts::Inside).new()\l<C Inside>$63: BadConsts::Inside = <castTemp>$69\l<C StaticField2>$73: Integer(2) = 2\l<blockReturnTemp>$45: NilClass = nil\l<blockReturnTemp>$74: T.noreturn = blockreturn<enums> <blockReturnTemp>$45: NilClass\l<unconditional>\l"
    ];

    "bb::<Class:BadConsts>#<static-init>_5" -> "bb::<Class:BadConsts>#<static-init>_2" [style="bold"];
}

subgraph "cluster_::BadConsts::<Class:Before>#<static-init>" {
    label = "::BadConsts::<Class:Before>#<static-init>";
    color = blue;
    "bb::BadConsts::<Class:Before>#<static-init>_0" [shape = invhouse];
    "bb::BadConsts::<Class:Before>#<static-init>_1" [shape = parallelogram];

    "bb::BadConsts::<Class:Before>#<static-init>_0" [
        label = "block[id=0, rubyBlockId=0]()\l<self>: T.class_of(BadConsts::Before) = cast(<self>: NilClass, AppliedType {\l  klass = <C <U BadConsts>><S <C <E <C <U Before>> $1>> $1>\l  targs = [\l    <C <U <AttachedClass>>> = SelfTypeParam(<C <U BadConsts>><S <C <E <C <U Before>> $1>> $1><C <U <AttachedClass>>>)\l  ]\l});\l<finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass\l<unconditional>\l"
    ];

    "bb::BadConsts::<Class:Before>#<static-init>_0" -> "bb::BadConsts::<Class:Before>#<static-init>_1" [style="bold"];
    "bb::BadConsts::<Class:Before>#<static-init>_1" [
        label = "block[id=1, rubyBlockId=0]()\l<unconditional>\l"
    ];

    "bb::BadConsts::<Class:Before>#<static-init>_1" -> "bb::BadConsts::<Class:Before>#<static-init>_1" [style="bold"];
}

subgraph "cluster_::BadConsts::<Class:Inside>#<static-init>" {
    label = "::BadConsts::<Class:Inside>#<static-init>";
    color = blue;
    "bb::BadConsts::<Class:Inside>#<static-init>_0" [shape = invhouse];
    "bb::BadConsts::<Class:Inside>#<static-init>_1" [shape = parallelogram];

    "bb::BadConsts::<Class:Inside>#<static-init>_0" [
        label = "block[id=0, rubyBlockId=0]()\l<self>: T.class_of(BadConsts::Inside) = cast(<self>: NilClass, AppliedType {\l  klass = <C <U BadConsts>><S <C <E <C <U Inside>> $1>> $1>\l  targs = [\l    <C <U <AttachedClass>>> = SelfTypeParam(<C <U BadConsts>><S <C <E <C <U Inside>> $1>> $1><C <U <AttachedClass>>>)\l  ]\l});\l<finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass\l<unconditional>\l"
    ];

    "bb::BadConsts::<Class:Inside>#<static-init>_0" -> "bb::BadConsts::<Class:Inside>#<static-init>_1" [style="bold"];
    "bb::BadConsts::<Class:Inside>#<static-init>_1" [
        label = "block[id=1, rubyBlockId=0]()\l<unconditional>\l"
    ];

    "bb::BadConsts::<Class:Inside>#<static-init>_1" -> "bb::BadConsts::<Class:Inside>#<static-init>_1" [style="bold"];
}

subgraph "cluster_::BadConsts::<Class:After>#<static-init>" {
    label = "::BadConsts::<Class:After>#<static-init>";
    color = blue;
    "bb::BadConsts::<Class:After>#<static-init>_0" [shape = invhouse];
    "bb::BadConsts::<Class:After>#<static-init>_1" [shape = parallelogram];

    "bb::BadConsts::<Class:After>#<static-init>_0" [
        label = "block[id=0, rubyBlockId=0]()\l<self>: T.class_of(BadConsts::After) = cast(<self>: NilClass, AppliedType {\l  klass = <C <U BadConsts>><S <C <E <C <U After>> $1>> $1>\l  targs = [\l    <C <U <AttachedClass>>> = SelfTypeParam(<C <U BadConsts>><S <C <E <C <U After>> $1>> $1><C <U <AttachedClass>>>)\l  ]\l});\l<finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass\l<unconditional>\l"
    ];

    "bb::BadConsts::<Class:After>#<static-init>_0" -> "bb::BadConsts::<Class:After>#<static-init>_1" [style="bold"];
    "bb::BadConsts::<Class:After>#<static-init>_1" [
        label = "block[id=1, rubyBlockId=0]()\l<unconditional>\l"
    ];

    "bb::BadConsts::<Class:After>#<static-init>_1" -> "bb::BadConsts::<Class:After>#<static-init>_1" [style="bold"];
}

}

